import {
  RESOURCE_MIME_TYPE,
  registerAppResource,
  registerAppTool,
} from "@modelcontextprotocol/ext-apps/server";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { ReadResourceResult } from "@modelcontextprotocol/sdk/types.js";
import crypto from "node:crypto";
import fs from "node:fs/promises";
import fsSync from "node:fs";
import path from "node:path";
import { z } from "zod";
import type { BrickDefinition } from "./src/bricks/types.js";
import { parseLDrawPart, setLDrawDir } from "./src/ldraw/ldraw-dimensions.js";

// Initialize LDraw directory for the server-side parser
const LDRAW_DIR = path.join(
  import.meta.filename.endsWith(".ts") ? import.meta.dirname : path.join(import.meta.dirname, ".."),
  "ldraw",
);
setLDrawDir(LDRAW_DIR);

const DIST_DIR = import.meta.filename.endsWith(".ts")
  ? path.join(import.meta.dirname, "dist")
  : import.meta.dirname;

// ── LDraw parts index (generated by scripts/generate-parts-index.ts) ────────

interface PartsIndexEntry {
  id: string;
  name: string;
}

interface PartsIndex {
  categories: Record<string, PartsIndexEntry[]>;
  totalParts: number;
  generatedAt: string;
}

let partsIndex: PartsIndex = { categories: {}, totalParts: 0, generatedAt: "" };
let allParts: { id: string; name: string; category: string }[] = [];

try {
  const indexPath = path.join(
    import.meta.filename.endsWith(".ts") ? import.meta.dirname : path.join(import.meta.dirname, ".."),
    "ldraw-parts-index.json",
  );
  const raw = fsSync.readFileSync(indexPath, "utf-8");
  partsIndex = JSON.parse(raw) as PartsIndex;
  for (const [category, parts] of Object.entries(partsIndex.categories)) {
    for (const part of parts) {
      allParts.push({ id: part.id, name: part.name, category });
    }
  }
  console.log(`Loaded LDraw parts index: ${partsIndex.totalParts} parts across ${Object.keys(partsIndex.categories).length} categories`);
} catch {
  console.warn("LDraw parts index not found — brick_search_parts will return empty results. Run 'npm run generate:index' to generate it.");
}

function findBrickType(typeId: string): BrickDefinition | undefined {
  return parseLDrawPart(typeId) ?? undefined;
}

// Popular LDraw part IDs for brick_get_available
const POPULAR_PART_IDS = [
  // Standard Bricks
  '3005', '3004', '3622', '3010', '3009', '3008',
  '3003', '3002', '3001', '2456', '3007',
  // Plates
  '3024', '3023', '3710', '3022', '3020', '3795',
  '3031', '3958', '3036', '3035', '4477',
  // Slopes
  '3039', '3040', '3665', '3660',
  // Technic
  '3700', '3701', '3894', '3702', '3709',
  // Corner
  '2357', '2462',
];

// ── Types ────────────────────────────────────────────────────────────────────

interface BrickInstance {
  id: string;
  typeId: string;
  position: { x: number; y: number; z: number };
  rotation: 0 | 90 | 180 | 270;
  color: string;
}

interface SceneData {
  name: string;
  bricks: BrickInstance[];
}

interface AABB {
  minX: number; maxX: number;
  minY: number; maxY: number;
  minZ: number; maxZ: number;
}

// ── Collision helpers ────────────────────────────────────────────────────────

function getBrickAABB(brick: BrickInstance, brickType: BrickDefinition): AABB {
  const { x, y, z } = brick.position;
  const isRotated = brick.rotation === 90 || brick.rotation === 270;
  const sx = isRotated ? brickType.studsZ : brickType.studsX;
  const sz = isRotated ? brickType.studsX : brickType.studsZ;
  return {
    minX: x, maxX: x + sx,
    minY: y, maxY: y + brickType.heightUnits,
    minZ: z, maxZ: z + sz,
  };
}

function aabbOverlap(a: AABB, b: AABB): boolean {
  return (
    a.minX < b.maxX && a.maxX > b.minX &&
    a.minY < b.maxY && a.maxY > b.minY &&
    a.minZ < b.maxZ && a.maxZ > b.minZ
  );
}

function checkCollision(
  bricks: BrickInstance[],
  newBrick: BrickInstance,
  newType: BrickDefinition,
  excludeId?: string,
): boolean {
  const newAABB = getBrickAABB(newBrick, newType);
  for (const existing of bricks) {
    if (excludeId && existing.id === excludeId) continue;
    const existType = findBrickType(existing.typeId);
    if (!existType) continue;
    const existAABB = getBrickAABB(existing, existType);
    if (aabbOverlap(newAABB, existAABB)) {
      return true;
    }
  }
  return false;
}

// ── Baseplate bounds ─────────────────────────────────────────────────────────

const BASEPLATE_SIZE = 48;

function checkBounds(brick: BrickInstance, brickType: BrickDefinition): string | null {
  const aabb = getBrickAABB(brick, brickType);
  if (aabb.minX < 0 || aabb.maxX > BASEPLATE_SIZE) {
    return `Brick extends outside baseplate on X axis (valid: 0–${BASEPLATE_SIZE - 1})`;
  }
  if (aabb.minZ < 0 || aabb.maxZ > BASEPLATE_SIZE) {
    return `Brick extends outside baseplate on Z axis (valid: 0–${BASEPLATE_SIZE - 1})`;
  }
  if (aabb.minY < 0) {
    return "Brick is below the baseplate";
  }
  return null;
}

function checkSupport(bricks: BrickInstance[], brick: BrickInstance, brickType: BrickDefinition): boolean {
  const aabb = getBrickAABB(brick, brickType);
  if (aabb.minY === 0) return true;

  for (const existing of bricks) {
    const et = findBrickType(existing.typeId);
    if (!et) continue;
    const ea = getBrickAABB(existing, et);
    if (ea.maxY !== aabb.minY) continue;
    // XZ overlap = support
    if (aabb.minX < ea.maxX && aabb.maxX > ea.minX &&
        aabb.minZ < ea.maxZ && aabb.maxZ > ea.minZ) {
      return true;
    }
  }
  return false;
}

function findUnsupported(bricks: BrickInstance[]): string[] {
  const unsupported: string[] = [];
  for (const brick of bricks) {
    const bt = findBrickType(brick.typeId);
    if (!bt) continue;
    if (!checkSupport(bricks.filter(b => b.id !== brick.id), brick, bt)) {
      unsupported.push(brick.id);
    }
  }
  return unsupported;
}

function generateId(): string {
  return crypto.randomUUID();
}

// ── Server factory ───────────────────────────────────────────────────────────

const resourceUri = "ui://brick-builder/mcp-app.html";

// ── Brick cheat sheet (returned by brick_read_me) ───────────────────────────

function buildCatalogCheatSheet(): string {
  let sheet = `# Brick Builder Reference

You only need to call brick_read_me once. Do NOT call it again — you will not see anything new.

## Order of Operations (MANDATORY — follow exactly)
1. brick_read_me → Call once to learn the building format and rules (you just did this)
2. brick_get_available → Call to see popular brick types and their dimensions
   - Optional: brick_search_parts → Search or browse the full library of ${partsIndex.totalParts}+ parts by name or category
3. brick_render_scene → Call BEFORE placing any bricks. This opens the 3D viewer for the user. If you skip this step, the user cannot see anything you build.
4. brick_place → Now you can place bricks. Each brick appears live in the viewer as it's placed.
5. brick_get_scene → Call anytime to inspect what's currently built
6. brick_remove_brick → Remove a specific brick by ID (use brick_get_scene to find IDs). Also removes unsupported bricks above it.
7. brick_clear_scene → Call to remove all bricks and start over

CRITICAL: You must call brick_render_scene before your first brick_place call. Placing bricks without rendering the scene first means the user has no viewer open and sees nothing.

## Brick Types
Any LDraw part number works as a typeId. Call brick_get_available to see popular parts with their dimensions. For the full library (${partsIndex.totalParts}+ parts), use brick_search_parts to search by name or browse by category. You can also use any valid LDraw part number (e.g. "2454", "4460", "6141") — the server auto-detects dimensions from the LDraw library.

## Coordinate System
- Baseplate: ${BASEPLATE_SIZE}×${BASEPLATE_SIZE} studs on the X and Z axes
- Y axis: height in plate units (1 standard brick = 3 Y units, 1 plate = 1 Y unit)
- Valid ranges: X 0–${BASEPLATE_SIZE - 1}, Z 0–${BASEPLATE_SIZE - 1}, Y 0+
- Rotation: "0", "90", "180", or "270" (string)
- Bricks CANNOT float — they must sit on the baseplate (Y=0) or on top of another brick
- ALL positions are relative to the baseplate. A brick's entire footprint (position + size) must stay within the ${BASEPLATE_SIZE}×${BASEPLATE_SIZE} baseplate. Out-of-bounds placements are rejected.
- A brick at position (x, z) with studsX=2, studsZ=4 occupies x to x+2, z to z+4. So the maximum valid x for that brick is ${BASEPLATE_SIZE - 2}, and the maximum valid z is ${BASEPLATE_SIZE - 4}.
- IMPORTANT: Every brick_place response includes a "footprint" showing the brick's exact occupied area: {minX, maxX, minZ, maxZ, topY}. Use footprint.maxX/maxZ to know where to place the NEXT brick adjacent to it. Use footprint.topY for the Y value of the next layer on top.
- brick_get_scene also returns footprints for every brick. ALWAYS read footprints to position new bricks — never calculate positions from scratch when existing bricks have footprints.

## Size & Scale Reference

Height is measured in bricks (1 brick = 3 plates = 3 Y units).
| Category       | Height        | Real-world approx |
|----------------|---------------|-------------------|
| Short          | 1–10 bricks   | up to ~9.6 cm     |
| Medium         | 11–30 bricks  | ~10–28 cm         |
| Tall           | 31–60 bricks  | ~29–57 cm         |
| Tower/Skyscraper | 60+ bricks | 57 cm+            |

Short builds sit flat on a table and are viewed mostly from above (vehicles, small vignettes, garden scenes). Medium builds are eye-catching at table height and viewed straight-on. Tall builds demand vertical presence and often need internal reinforcement.

Width is measured in studs (1 stud = 8 mm).
| Category | Width       | Real-world approx |
|----------|-------------|-------------------|
| Narrow   | 1–8 studs   | up to ~6.4 cm     |
| Medium   | 9–24 studs  | ~7–19 cm          |
| Wide     | 25–48 studs | ~20–38 cm         |
| Massive  | 48+ studs   | 38 cm+            |

Narrow builds are things like a single tower, a lamppost, or a small character model. Medium is the sweet spot for most standalone builds — a small house, a vehicle, a diorama scene. Wide and massive are dioramas, modular-style buildings, and layout sections.

## Colors
Red #cc0000 · Blue #0055bf · Green #237841 · Yellow #f2cd37 · White #ffffff · Black #1b2a34
Orange #fe8a18 · Brown #583927 · Tan #e4cd9e · Dark grey #6b5a5a · Light grey #9ba19d · Dark blue #0a3463

## Footprints

Every brick_place response and brick_get_scene response includes a "footprint" for each brick:
  { minX, maxX, minZ, maxZ, topY }

This tells you the exact area the brick occupies on the baseplate after rotation is applied.
- minX/maxX: the brick spans from minX to maxX along the X axis
- minZ/maxZ: the brick spans from minZ to maxZ along the Z axis
- topY: the top of the brick — use this as the Y value for stacking a brick on top

Use footprints to position new bricks. Do NOT calculate positions manually — read the footprint from the response.
- To place a brick adjacent along X: use the previous brick's footprint.maxX as the new brick's x
- To place a brick adjacent along Z: use the previous brick's footprint.maxZ as the new brick's z
- To stack on top: use the previous brick's footprint.topY as the new brick's y

Example: you place a 2x4 brick (typeId="3001") at (10, 0, 10) with rotation "90". The response includes:
  footprint: { minX: 10, maxX: 14, minZ: 10, maxZ: 12, topY: 3 }
To place the next brick to the right: x=14 (footprint.maxX)
To place a brick in front: z=12 (footprint.maxZ)
To stack on top: y=3 (footprint.topY)

## Examples

Each brick_place call places ONE brick. Build bottom-up — always place supports before the bricks on top.

### Wall (4 bricks tall)
Place first brick, then use footprint.topY for each subsequent layer:
  brick_place(typeId="3008", x=10, y=0, z=10, color="#cc0000")   ← 3008 = Brick 1x8
    → footprint: {minX:10, maxX:11, minZ:10, maxZ:18, topY:3}
  brick_place(typeId="3008", x=10, y=3, z=10, color="#cc0000")   ← y=3 from topY
    → footprint: {minX:10, maxX:11, minZ:10, maxZ:18, topY:6}
  brick_place(typeId="3008", x=10, y=6, z=10, color="#cc0000")   ← y=6 from topY
  brick_place(typeId="3008", x=10, y=9, z=10, color="#cc0000")   ← y=9 from topY

### Placing side by side along Z
Use footprint.maxZ from each response for the next brick's z:
  brick_place(typeId="3001", x=10, y=0, z=10, color="#cc0000")   ← 3001 = Brick 2x4
    → footprint: {minX:10, maxX:12, minZ:10, maxZ:14, topY:3}
  brick_place(typeId="3001", x=10, y=0, z=14, color="#0055bf")   ← z=14 from maxZ
    → footprint: {minX:10, maxX:12, minZ:14, maxZ:18, topY:3}
  brick_place(typeId="3001", x=10, y=0, z=18, color="#237841")   ← z=18 from maxZ

### Placing side by side along X
Use footprint.maxX from each response for the next brick's x:
  brick_place(typeId="3001", x=10, y=0, z=10, color="#cc0000")   ← 3001 = Brick 2x4
    → footprint: {minX:10, maxX:12, minZ:10, maxZ:14, topY:3}
  brick_place(typeId="3001", x=12, y=0, z=10, color="#0055bf")   ← x=12 from maxX
  brick_place(typeId="3001", x=14, y=0, z=10, color="#237841")   ← x=14 from maxX

### Rotation changes footprint — always read it
  3001 (Brick 2x4) at rotation "0":  footprint maxX = x+2, maxZ = z+4
  3001 (Brick 2x4) at rotation "90": footprint maxX = x+4, maxZ = z+2  (swapped!)

## Rules
- Build BOTTOM-UP: y=0 first, then y=3, y=6, etc. Floating bricks are rejected.
- Use typeId values from brick_get_available for popular parts. You can also use any LDraw part number — the server will auto-detect dimensions from the LDraw library.
- Each brick_place returns success with the brick ID, or an error explaining why it failed. Read the error and adjust.
- Rotation swaps dimensions — account for this when tiling.
- ALL bricks must fit within the ${BASEPLATE_SIZE}×${BASEPLATE_SIZE} baseplate. The brick's full footprint (position + studs size) must not exceed x=${BASEPLATE_SIZE - 1} or z=${BASEPLATE_SIZE - 1}. Out-of-bounds placements are rejected.
- BEFORE placing a new brick, call brick_get_scene to see where existing bricks are. Position new bricks RELATIVE to what's already placed — adjacent to, on top of, or next to existing bricks. Never guess positions from scratch when there are already bricks in the scene.

## Building Strategy
1. Call brick_get_scene FIRST to see what's already built. Always place new bricks relative to existing ones.
2. Plan the footprint first — lay the ground floor (Y=0)
3. Build upward layer by layer — each layer's Y = previous Y + heightUnits
4. Place one brick at a time. Read each response — if placement fails, adjust and retry.
5. Alternate brick offsets between rows for realistic interlocking
6. Use plates (heightUnits=1) for thin details, trim, and floors
7. Use slopes for rooflines — studs are only on the flat side
8. Build in sections: foundation → walls → roof

## Best Practices
- Work at a scale that makes sense for the detail level you want. Larger scale gives more room for realism.
- Plan your color scheme early. Mixing too many colors by accident is a common mistake — pick 2-3 main colors and 1-2 accent colors.
- Overlap your layers like real brickwork — never stack bricks where joints align vertically. That creates weak seam lines. Offset by half a brick length on alternating rows.
- Distribute weight evenly and think about the base. Wide, flat bases are more stable than tall narrow towers without internal reinforcement.
- Use Technic bricks internally for rigid structural support, especially in large builds.
- Use consistent lighting logic — if your build has a light source, shade the darker side with darker colored bricks.
- Finish exposed surfaces with plates for a clean, polished look. Use slopes for angled surfaces and rooflines.
- For sci-fi and industrial builds, add small technical-looking details (greebling) with 1x1 bricks and plates, but apply with restraint so it doesn't look random.
- Don't be afraid to use brick_clear_scene and rebuild. The best builders redo sections many times.
- Step back and consider the build from the intended viewing angle, not just from above.
`;

  return sheet;
}

// Shared scene state — the host creates separate MCP sessions for the LLM
// and the app iframe, so per-closure state won't be visible across both.
// Module-level state ensures both sessions read/write the same scene.
let scene: SceneData = { name: "Untitled", bricks: [] };

export function createServer(): McpServer {
  const server = new McpServer({
    name: "Brick Builder",
    version: "1.0.0",
  }, {
    instructions: `3D brick construction tool. IMPORTANT: Always call brick_read_me first to learn available brick types and their dimensions before building anything. Brick type IDs are LDraw part numbers (e.g. "3001" = Brick 2x4). Call brick_get_available to see popular parts, but you can also use any valid LDraw part number — dimensions are auto-detected.`,
  });

  function collectDynamicTypes(): Record<string, BrickDefinition> | undefined {
    const dynamic: Record<string, BrickDefinition> = {};
    for (const brick of scene.bricks) {
      if (!dynamic[brick.typeId]) {
        const def = findBrickType(brick.typeId);
        if (def) dynamic[brick.typeId] = def;
      }
    }
    return Object.keys(dynamic).length > 0 ? dynamic : undefined;
  }

  function scenePayload(message?: string) {
    const dynamicTypes = collectDynamicTypes();
    return {
      scene: {
        ...scene,
        ...(dynamicTypes ? { dynamicTypes } : {}),
      },
      ...(message ? { message } : {}),
    };
  }

  function sceneResult(message?: string) {
    const payload = scenePayload(message);
    return {
      content: [{ type: "text" as const, text: JSON.stringify(payload) }],
    };
  }

  // ── Tool 1: brick_read_me (model-only, no frame) ───────────────────────

  server.registerTool(
    "brick_read_me",
    {
      description: "Returns the building guide, coordinate system, and examples. Call this BEFORE using any other brick tool for the first time.",
      annotations: { readOnlyHint: true },
    },
    async () => ({
      content: [{ type: "text" as const, text: buildCatalogCheatSheet() }],
    }),
  );

  // ── Tool 2: brick_get_available (model-only, no frame) ────────────────

  server.registerTool(
    "brick_get_available",
    {
      description: "Returns popular brick types with their IDs and dimensions. You can also use any LDraw part number not listed here. For the full library (15,000+ parts), use brick_search_parts to search or browse by category. Call this to learn what bricks you can use before building.",
      annotations: { readOnlyHint: true },
    },
    async () => {
      const parts: { typeId: string; name: string; studsX: number; studsZ: number; heightUnits: number }[] = [];
      for (const partId of POPULAR_PART_IDS) {
        const def = parseLDrawPart(partId);
        if (def) {
          parts.push({
            typeId: def.id,
            name: def.name,
            studsX: def.studsX,
            studsZ: def.studsZ,
            heightUnits: def.heightUnits,
          });
        }
      }
      const result = {
        parts,
        note: "typeId values are LDraw part numbers (e.g. '3001' = Brick 2x4). Use exact typeId values in brick_place. Rotation swaps X and Z dimensions (e.g. 3001 at rotation 90 occupies X=4, Z=2). You can also use any valid LDraw part number not listed here — dimensions are auto-detected.",
      };
      return { content: [{ type: "text" as const, text: JSON.stringify(result) }] };
    },
  );

  // ── Tool 2b: brick_search_parts (model-only, no frame) ─────────────────

  server.registerTool(
    "brick_search_parts",
    {
      description:
        "Search or browse the full LDraw parts library. Without arguments, returns all categories with part counts. Use 'query' to search by name, 'category' to browse a specific category, or both to search within a category. Results are paginated.",
      inputSchema: {
        query: z.string().optional().describe("Search term to match against part names (case-insensitive substring match)"),
        category: z.string().optional().describe("Filter to a specific category (e.g. 'Brick', 'Plate', 'Slope')"),
        offset: z.number().int().min(0).optional().default(0).describe("Pagination offset (default 0)"),
        limit: z.number().int().min(1).max(50).optional().default(25).describe("Results per page (default 25, max 50)"),
      },
      annotations: { readOnlyHint: true },
    },
    async ({ query, category, offset, limit }) => {
      const off = offset ?? 0;
      const lim = limit ?? 25;

      // No query, no category → list all categories with counts
      if (!query && !category) {
        const categoryList = Object.entries(partsIndex.categories)
          .map(([name, parts]) => ({ name, count: parts.length }))
          .sort((a, b) => b.count - a.count);
        return {
          content: [{
            type: "text" as const,
            text: JSON.stringify({
              totalParts: partsIndex.totalParts,
              categories: categoryList,
              hint: "Use 'category' to browse parts in a category, or 'query' to search by name.",
            }),
          }],
        };
      }

      // Filter parts
      let results: { id: string; name: string; category: string }[];
      if (category && !query) {
        // Browse a specific category
        const parts = partsIndex.categories[category];
        if (!parts) {
          // Try case-insensitive match
          const match = Object.keys(partsIndex.categories).find(
            (c) => c.toLowerCase() === category.toLowerCase(),
          );
          if (match) {
            results = partsIndex.categories[match].map((p) => ({ ...p, category: match }));
          } else {
            return {
              content: [{
                type: "text" as const,
                text: JSON.stringify({
                  error: `Category "${category}" not found.`,
                  availableCategories: Object.keys(partsIndex.categories).sort(),
                }),
              }],
              isError: true,
            };
          }
        } else {
          results = parts.map((p) => ({ ...p, category }));
        }
      } else if (query && !category) {
        // Search all parts by name
        const q = query.toLowerCase();
        results = allParts.filter((p) => p.name.toLowerCase().includes(q));
      } else {
        // Search within a specific category
        const q = query!.toLowerCase();
        const catName =
          partsIndex.categories[category!]
            ? category!
            : Object.keys(partsIndex.categories).find(
                (c) => c.toLowerCase() === category!.toLowerCase(),
              );
        if (!catName || !partsIndex.categories[catName]) {
          return {
            content: [{
              type: "text" as const,
              text: JSON.stringify({
                error: `Category "${category}" not found.`,
                availableCategories: Object.keys(partsIndex.categories).sort(),
              }),
            }],
            isError: true,
          };
        }
        results = partsIndex.categories[catName]
          .filter((p) => p.name.toLowerCase().includes(q))
          .map((p) => ({ ...p, category: catName }));
      }

      const total = results.length;
      const page = results.slice(off, off + lim);

      return {
        content: [{
          type: "text" as const,
          text: JSON.stringify({
            results: page,
            total,
            offset: off,
            limit: lim,
            hasMore: off + lim < total,
          }),
        }],
      };
    },
  );

  // ── Tool 3: brick_render_scene (model-only, creates frame) ────────────

  registerAppTool(
    server,
    "brick_render_scene",
    {
      title: "Render Brick Scene",
      description: "Opens the 3D brick builder viewer. You MUST call this before brick_place so the user can see the bricks. Call brick_read_me first to learn the brick format.",
      inputSchema: {},
      _meta: { ui: { resourceUri } },
    },
    async () => sceneResult("Scene rendered"),
  );

  // ── Tool 4: brick_place (model-facing, no UI metadata) ────────────────

  server.registerTool(
    "brick_place",
    {
      description: "Place a single brick. Returns the placed brick with its ID, or an error explaining why placement failed. Call brick_render_scene first to open the viewer.",
      inputSchema: {
        typeId: z.string().describe("Brick type ID from brick_get_available or any LDraw part number"),
        x: z.number().int().describe(`X position in stud units (0 to ${BASEPLATE_SIZE - 1})`),
        y: z.number().int().min(0).describe("Y position in plate-height units (0 = baseplate, +3 per standard brick layer)"),
        z: z.number().int().describe(`Z position in stud units (0 to ${BASEPLATE_SIZE - 1})`),
        rotation: z.enum(["0", "90", "180", "270"]).optional().default("0").describe("Rotation degrees. Swaps X/Z dimensions: e.g. 3001 (Brick 2x4) at 90° occupies X=4, Z=2"),
        color: z.string().optional().default("#cc0000").describe("Hex color"),
      },
    },
    async ({ typeId, x, y, z, rotation, color }) => {
      const brickType = findBrickType(typeId);
      if (!brickType) {
        return {
          content: [{ type: "text" as const, text: JSON.stringify({ error: `Unknown brick type "${typeId}". Call brick_get_available to see valid type IDs, or use any valid LDraw part number.` }) }],
          isError: true,
        };
      }
      const instance: BrickInstance = {
        id: generateId(),
        typeId,
        position: { x, y, z },
        rotation: Number(rotation ?? "0") as 0 | 90 | 180 | 270,
        color: color ?? "#cc0000",
      };
      const boundsError = checkBounds(instance, brickType);
      if (boundsError) {
        return {
          content: [{ type: "text" as const, text: JSON.stringify({ error: boundsError, position: { x, y, z }, typeId }) }],
          isError: true,
        };
      }
      if (!checkSupport(scene.bricks, instance, brickType)) {
        return {
          content: [{ type: "text" as const, text: JSON.stringify({ error: "No support — brick must be on baseplate (y=0) or resting on top of another brick", position: { x, y, z }, typeId }) }],
          isError: true,
        };
      }
      if (checkCollision(scene.bricks, instance, brickType)) {
        return {
          content: [{ type: "text" as const, text: JSON.stringify({ error: "Collision — overlaps an existing brick", position: { x, y, z }, typeId }) }],
          isError: true,
        };
      }
      scene.bricks.push(instance);
      const aabb = getBrickAABB(instance, brickType);
      return {
        content: [{ type: "text" as const, text: JSON.stringify({
          placed: {
            id: instance.id,
            typeId,
            position: { x, y, z },
            rotation: instance.rotation,
            color: instance.color,
            footprint: {
              minX: aabb.minX, maxX: aabb.maxX,
              minZ: aabb.minZ, maxZ: aabb.maxZ,
              topY: aabb.maxY,
            },
          },
          totalBricks: scene.bricks.length,
        }) }],
      };
    },
  );

  // ── Tool 5: brick_get_scene (model-only, no frame) ──────────────────────

  server.registerTool(
    "brick_get_scene",
    {
      description: "Returns the current scene state with all placed bricks and their footprints. Use this before placing new bricks to see where existing bricks are.",
      annotations: { readOnlyHint: true },
    },
    async () => {
      const bricksWithFootprints = scene.bricks.map(b => {
        const bt = findBrickType(b.typeId);
        if (!bt) return b;
        const aabb = getBrickAABB(b, bt);
        return {
          ...b,
          footprint: {
            minX: aabb.minX, maxX: aabb.maxX,
            minZ: aabb.minZ, maxZ: aabb.maxZ,
            topY: aabb.maxY,
          },
        };
      });
      const dynamicTypes = collectDynamicTypes();
      return {
        content: [{ type: "text" as const, text: JSON.stringify({
          scene: {
            ...scene,
            bricks: bricksWithFootprints,
            ...(dynamicTypes ? { dynamicTypes } : {}),
          },
        }) }],
      };
    },
  );

  // ── Tool 6: brick_clear_scene (model-facing, no UI metadata) ──────────

  server.registerTool(
    "brick_clear_scene",
    {
      description: "Remove all bricks from the scene.",
      annotations: { destructiveHint: true },
    },
    async () => {
      const count = scene.bricks.length;
      scene.bricks = [];
      return sceneResult(`Cleared ${count} bricks`);
    },
  );

  // ── Tool 7: brick_remove_brick (model-facing, no UI metadata) ──────────

  server.registerTool(
    "brick_remove_brick",
    {
      description: "Remove a single brick by its ID. Use brick_get_scene to find brick IDs. Also removes any bricks that lose support as a result.",
      inputSchema: {
        brickId: z.string().describe("ID of the brick to remove (from brick_get_scene or brick_place response)"),
      },
      annotations: { destructiveHint: true },
    },
    async ({ brickId }) => {
      const idx = scene.bricks.findIndex((b) => b.id === brickId);
      if (idx === -1) {
        return {
          content: [{ type: "text" as const, text: JSON.stringify({ error: `Brick not found: "${brickId}". Call brick_get_scene to see current brick IDs.` }) }],
          isError: true,
        };
      }
      const removed = scene.bricks[idx];
      scene.bricks.splice(idx, 1);
      // Cascade: remove any bricks left unsupported
      let cascadeCount = 0;
      let changed = true;
      while (changed) {
        changed = false;
        const unsupported = findUnsupported(scene.bricks);
        if (unsupported.length > 0) {
          scene.bricks = scene.bricks.filter(b => !unsupported.includes(b.id));
          cascadeCount += unsupported.length;
          changed = true;
        }
      }
      const msg = `Removed ${removed.typeId} from (${removed.position.x}, ${removed.position.y}, ${removed.position.z})` +
        (cascadeCount > 0 ? `. Also removed ${cascadeCount} unsupported brick(s) above it.` : "");
      return {
        content: [{ type: "text" as const, text: JSON.stringify({
          removed: { id: removed.id, typeId: removed.typeId, position: removed.position },
          cascadeRemoved: cascadeCount,
          totalBricks: scene.bricks.length,
          message: msg,
        }) }],
      };
    },
  );

  // ── Tool 8: brick_export_scene (no frame) ────────────────────────────────

  server.registerTool(
    "brick_export_scene",
    {
      description: "Export the scene as JSON or a summary.",
      inputSchema: {
        format: z.enum(["json", "summary"]).default("summary").describe("Export format"),
      },
      annotations: { readOnlyHint: true },
    },
    async ({ format }) => {
      if (format === "json") {
        return {
          content: [{ type: "text" as const, text: JSON.stringify(scene, null, 2) }],
        };
      }
      // Summary
      const count = scene.bricks.length;
      if (count === 0) {
        return {
          content: [{ type: "text" as const, text: JSON.stringify({ name: scene.name, brickCount: 0 }) }],
        };
      }
      const colorCounts: Record<string, number> = {};
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      let minZ = Infinity, maxZ = -Infinity;
      for (const b of scene.bricks) {
        colorCounts[b.color] = (colorCounts[b.color] || 0) + 1;
        const bt = findBrickType(b.typeId);
        if (!bt) continue;
        const aabb = getBrickAABB(b, bt);
        minX = Math.min(minX, aabb.minX); maxX = Math.max(maxX, aabb.maxX);
        minY = Math.min(minY, aabb.minY); maxY = Math.max(maxY, aabb.maxY);
        minZ = Math.min(minZ, aabb.minZ); maxZ = Math.max(maxZ, aabb.maxZ);
      }
      const summary = {
        name: scene.name,
        brickCount: count,
        dimensions: { x: maxX - minX, y: maxY - minY, z: maxZ - minZ },
        colors: colorCounts,
      };
      return { content: [{ type: "text" as const, text: JSON.stringify(summary) }] };
    },
  );

  // ── Tool 9: brick_add (app-only) ────────────────────────────────────────

  registerAppTool(
    server,
    "brick_add",
    {
      title: "Add Brick",
      description: `Add a single brick to the scene. The baseplate is ${BASEPLATE_SIZE}×${BASEPLATE_SIZE} studs. Valid coordinates: x 0–${BASEPLATE_SIZE - 1}, z 0–${BASEPLATE_SIZE - 1}.`,
      inputSchema: {
        typeId: z.string().describe("Brick type ID (LDraw part number)"),
        x: z.number().int().describe(`X position in stud units (0 to ${BASEPLATE_SIZE - 1})`),
        y: z.number().int().min(0).describe("Y position (plate-height units)"),
        z: z.number().int().describe(`Z position in stud units (0 to ${BASEPLATE_SIZE - 1})`),
        rotation: z.enum(["0", "90", "180", "270"]).optional().default("0").describe("Rotation degrees"),
        color: z.string().optional().default("#cc0000").describe("Hex color"),
      },
      _meta: { ui: { visibility: ["app"] } },
    },
    async ({ typeId, x, y, z, rotation, color }) => {
      const brickType = findBrickType(typeId);
      if (!brickType) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Unknown brick type "${typeId}". Use a valid LDraw part number.` }) }], isError: true };
      }
      const instance: BrickInstance = {
        id: generateId(),
        typeId,
        position: { x, y, z },
        rotation: Number(rotation) as 0 | 90 | 180 | 270,
        color: color ?? "#cc0000",
      };
      const boundsError = checkBounds(instance, brickType);
      if (boundsError) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `${typeId} at (${x},${y},${z}): ${boundsError}` }) }], isError: true };
      }
      if (!checkSupport(scene.bricks, instance, brickType)) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `${typeId} at (${x},${y},${z}): no support — must be on baseplate (Y=0) or resting on top of another brick` }) }], isError: true };
      }
      if (checkCollision(scene.bricks, instance, brickType)) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `${typeId} at (${x},${y},${z}): collision — overlaps an existing brick` }) }], isError: true };
      }
      scene.bricks.push(instance);
      return sceneResult(`Added ${brickType.name} at (${x}, ${y}, ${z})`);
    },
  );

  // ── Tool 10: brick_remove (app-only) ─────────────────────────────────────

  registerAppTool(
    server,
    "brick_remove",
    {
      title: "Remove Brick",
      description: "Remove a brick by its ID.",
      inputSchema: {
        brickId: z.string().describe("ID of the brick to remove"),
      },
      _meta: { ui: { visibility: ["app"] } },
    },
    async ({ brickId }) => {
      const idx = scene.bricks.findIndex((b) => b.id === brickId);
      if (idx === -1) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Brick not found: "${brickId}". It may have already been removed. Call brick_get_scene to see current bricks.` }) }], isError: true };
      }
      const removed = scene.bricks[idx];
      scene.bricks.splice(idx, 1);
      // Cascade: remove any bricks left unsupported
      let cascadeCount = 0;
      let changed = true;
      while (changed) {
        changed = false;
        const unsupported = findUnsupported(scene.bricks);
        if (unsupported.length > 0) {
          scene.bricks = scene.bricks.filter(b => !unsupported.includes(b.id));
          cascadeCount += unsupported.length;
          changed = true;
        }
      }

      const msg = `Removed ${removed.typeId} from (${removed.position.x}, ${removed.position.y}, ${removed.position.z})` +
        (cascadeCount > 0 ? `. Also removed ${cascadeCount} unsupported brick(s) above it.` : "");
      return sceneResult(msg);
    },
  );

  // ── Tool 11: brick_move (app-only) ───────────────────────────────────────

  registerAppTool(
    server,
    "brick_move",
    {
      title: "Move Brick",
      description: "Move a brick to a new position.",
      inputSchema: {
        brickId: z.string().describe("ID of the brick to move"),
        x: z.number().int().describe("New X position"),
        y: z.number().int().min(0).describe("New Y position"),
        z: z.number().int().describe("New Z position"),
      },
      _meta: { ui: { visibility: ["app"] } },
    },
    async ({ brickId, x, y, z }) => {
      const brick = scene.bricks.find((b) => b.id === brickId);
      if (!brick) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Brick not found: "${brickId}". It may have been removed. Call brick_get_scene to see current bricks.` }) }], isError: true };
      }
      const brickType = findBrickType(brick.typeId);
      if (!brickType) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Invalid brick type "${brick.typeId}" on brick ${brickId}.` }) }], isError: true };
      }
      const moved: BrickInstance = { ...brick, position: { x, y, z } };
      const boundsError = checkBounds(moved, brickType);
      if (boundsError) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Cannot move ${brick.typeId} to (${x},${y},${z}): ${boundsError}` }) }], isError: true };
      }
      if (!checkSupport(scene.bricks.filter(b => b.id !== brickId), moved, brickType)) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Cannot move ${brick.typeId} to (${x},${y},${z}): no support — must be on baseplate (Y=0) or resting on top of another brick` }) }], isError: true };
      }
      if (checkCollision(scene.bricks, moved, brickType, brickId)) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Cannot move ${brick.typeId} to (${x},${y},${z}): collision — overlaps an existing brick` }) }], isError: true };
      }
      const oldPos = { ...brick.position };
      brick.position = { x, y, z };
      // Cascade: remove any bricks left unsupported by this move
      let cascadeCount = 0;
      let changed = true;
      while (changed) {
        changed = false;
        const unsupported = findUnsupported(scene.bricks);
        if (unsupported.length > 0) {
          scene.bricks = scene.bricks.filter(b => !unsupported.includes(b.id));
          cascadeCount += unsupported.length;
          changed = true;
        }
      }

      const msg = `Moved ${brick.typeId} from (${oldPos.x},${oldPos.y},${oldPos.z}) to (${x}, ${y}, ${z})` +
        (cascadeCount > 0 ? `. Removed ${cascadeCount} unsupported brick(s) that were above old position.` : "");
      return sceneResult(msg);
    },
  );

  // ── Tool 12: brick_rotate (app-only) ────────────────────────────────────

  registerAppTool(
    server,
    "brick_rotate",
    {
      title: "Rotate Brick",
      description: "Set a brick's rotation.",
      inputSchema: {
        brickId: z.string().describe("ID of the brick to rotate"),
        rotation: z.enum(["0", "90", "180", "270"]).describe("New rotation in degrees"),
      },
      _meta: { ui: { visibility: ["app"] } },
    },
    async ({ brickId, rotation }) => {
      const brick = scene.bricks.find((b) => b.id === brickId);
      if (!brick) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Brick not found: "${brickId}". It may have been removed. Call brick_get_scene to see current bricks.` }) }], isError: true };
      }
      const brickType = findBrickType(brick.typeId);
      if (!brickType) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Invalid brick type "${brick.typeId}" on brick ${brickId}.` }) }], isError: true };
      }
      const rotated: BrickInstance = { ...brick, rotation: Number(rotation) as 0 | 90 | 180 | 270 };
      const boundsError = checkBounds(rotated, brickType);
      if (boundsError) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Cannot rotate ${brick.typeId} at (${brick.position.x},${brick.position.y},${brick.position.z}) to ${rotation}°: ${boundsError}` }) }], isError: true };
      }
      // Check self-support after rotation (footprint changes)
      if (!checkSupport(scene.bricks.filter(b => b.id !== brickId), rotated, brickType)) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Cannot rotate ${brick.typeId} at (${brick.position.x},${brick.position.y},${brick.position.z}) to ${rotation}°: no support after rotation — brick would float` }) }], isError: true };
      }
      if (checkCollision(scene.bricks, rotated, brickType, brickId)) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Cannot rotate ${brick.typeId} at (${brick.position.x},${brick.position.y},${brick.position.z}) to ${rotation}°: collision — overlaps an existing brick` }) }], isError: true };
      }
      brick.rotation = Number(rotation) as 0 | 90 | 180 | 270;
      // Cascade: remove any bricks left unsupported by the footprint change
      let cascadeCount = 0;
      let changed = true;
      while (changed) {
        changed = false;
        const unsupported = findUnsupported(scene.bricks);
        if (unsupported.length > 0) {
          scene.bricks = scene.bricks.filter(b => !unsupported.includes(b.id));
          cascadeCount += unsupported.length;
          changed = true;
        }
      }

      const msg = `Rotated ${brick.typeId} at (${brick.position.x}, ${brick.position.y}, ${brick.position.z}) to ${rotation}°` +
        (cascadeCount > 0 ? `. Removed ${cascadeCount} unsupported brick(s) above.` : "");
      return sceneResult(msg);
    },
  );

  // ── Tool 13: brick_paint (app-only) ─────────────────────────────────────

  registerAppTool(
    server,
    "brick_paint",
    {
      title: "Paint Brick",
      description: "Change a brick's color.",
      inputSchema: {
        brickId: z.string().describe("ID of the brick to paint"),
        color: z.string().describe("New hex color"),
      },
      _meta: { ui: { visibility: ["app"] } },
    },
    async ({ brickId, color }) => {
      const brick = scene.bricks.find((b) => b.id === brickId);
      if (!brick) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Brick not found: "${brickId}". It may have been removed. Call brick_get_scene to see current bricks.` }) }], isError: true };
      }
      brick.color = color;
      return sceneResult(`Painted ${brick.typeId} at (${brick.position.x}, ${brick.position.y}, ${brick.position.z}) → ${color}`);
    },
  );

  // ── Tool 14: brick_set_camera (app-only) ────────────────────────────────

  registerAppTool(
    server,
    "brick_set_camera",
    {
      title: "Set Camera",
      description: "Set the camera position and look-at target.",
      inputSchema: {
        posX: z.number().describe("Camera X position"),
        posY: z.number().describe("Camera Y position"),
        posZ: z.number().describe("Camera Z position"),
        targetX: z.number().optional().default(0).describe("Look-at X"),
        targetY: z.number().optional().default(0).describe("Look-at Y"),
        targetZ: z.number().optional().default(0).describe("Look-at Z"),
      },
      _meta: { ui: { visibility: ["app"] } },
    },
    async ({ posX, posY, posZ, targetX, targetY, targetZ }) => {
      const payload = {
        scene,
        camera: {
          position: { x: posX, y: posY, z: posZ },
          target: { x: targetX ?? 0, y: targetY ?? 0, z: targetZ ?? 0 },
        },
        message: "Camera updated",
      };
      return { content: [{ type: "text" as const, text: JSON.stringify(payload) }] };
    },
  );

  // ── Tool 15: brick_import_scene (app-only) ──────────────────────────────

  registerAppTool(
    server,
    "brick_import_scene",
    {
      title: "Import Scene",
      description: "Import a scene from JSON.",
      inputSchema: {
        sceneJson: z.string().describe("Scene JSON string"),
      },
      _meta: { ui: { visibility: ["app"] } },
    },
    async ({ sceneJson }) => {
      try {
        const imported = JSON.parse(sceneJson);
        if (!imported.name || !Array.isArray(imported.bricks)) {
          return { content: [{ type: "text" as const, text: JSON.stringify({ error: 'Invalid scene format — expected { "name": "...", "bricks": [...] }' }) }], isError: true };
        }
        // Validate all bricks: sort by Y and re-add with full validation
        const raw: BrickInstance[] = imported.bricks;
        const sorted = [...raw].sort((a, b) => a.position.y - b.position.y);
        const valid: BrickInstance[] = [];
        let dropped = 0;
        for (const brick of sorted) {
          const bt = findBrickType(brick.typeId);
          if (!bt) { dropped++; continue; }
          if (checkBounds(brick, bt)) { dropped++; continue; }
          if (!checkSupport(valid, brick, bt)) { dropped++; continue; }
          if (checkCollision(valid, brick, bt)) { dropped++; continue; }
          valid.push(brick);
        }
        scene = { name: imported.name, bricks: valid };
        const msg = `Imported scene '${scene.name}' with ${valid.length} bricks` +
          (dropped > 0 ? ` (dropped ${dropped} invalid/floating/colliding bricks)` : "");
        return sceneResult(msg);
      } catch (e) {
        return { content: [{ type: "text" as const, text: JSON.stringify({ error: `Invalid JSON: ${e instanceof Error ? e.message : "parse error"}` }) }], isError: true };
      }
    },
  );

  // ── Tool 16: brick_set_scene_name (app-only) ────────────────────────────

  registerAppTool(
    server,
    "brick_set_scene_name",
    {
      title: "Set Scene Name",
      description: "Set the scene's display name.",
      inputSchema: {
        name: z.string().describe("New scene name"),
      },
      _meta: { ui: { visibility: ["app"] } },
    },
    async ({ name }) => {
      scene.name = name;
      return sceneResult(`Scene renamed to '${name}'`);
    },
  );

  // ── Resource registration ───────────────────────────────────────────────

  registerAppResource(
    server,
    resourceUri,
    resourceUri,
    { mimeType: RESOURCE_MIME_TYPE, description: "Brick Builder UI" },
    async (): Promise<ReadResourceResult> => {
      const html = await fs.readFile(path.join(DIST_DIR, "mcp-app.html"), "utf-8");
      return {
        contents: [{ uri: resourceUri, mimeType: RESOURCE_MIME_TYPE, text: html }],
      };
    },
  );

  return server;
}
